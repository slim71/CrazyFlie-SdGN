- periodic recalibration needed to ensure good precision
- fixed reference system:
	"Vicon system"
	room centre
- asymmetric markers on Drone to ensure distinction from environment
- sw objects linked to physical objects:
	name/alias
	body reference system -> initialized at desired position/orientation
- purpose:
	track following of Wand position
- Wand position -> target
- Kalman filter used
- orientations with quaternions:
	used in the project for ref. systems conversions
	not fed to KF
- it uses an EKF


Basics
- Tracker gets Drone and Wand position/orientation through cameras and markers
- program on PC gets pos/or through Vicon-SSDK library
- program on PC computes needed conversions
- program on PC, through Crazyradio and Python libs for CRPT protocol:
	feeds to the Drone a new target pos (from Wand pos)
	feeds to the Drone KF input (own position)
	

Crazy Real Time Protocol (CRTP)
- developed by Bitcraze
- ACK
- TX (Crazyradio on PC) and RX (Drone)

- packet size: only data payload is considered
- port 6: to manage pos/or
    channel 0: to send the Drone its position, as acquired from an external system
               (x,y,z) [m]
    channel 1: to host packets useful for the localization subsystem
               (ID, payload)
- must use channel 1 if both pos and or are needed (more space)

- CrtpExtPose.py, ptx.py, prx.py?

- MotionCommander: allow to make the take-off "automatic" once Drone class is generated
- MAYBE IMPORTANT: MotionCommander only for take-off, Commander for everything else
- TODO: check differences from original cflib
- GetSegmentGlobalRotationEulerXYZ: to get rotation matrix indicating the orientation of an object, relative to the
    fixed Vicon reference system
- GetSegmentGlobalTranslation: to get the translation of the Body ref. system of an object, relative to the fixed Vicon
    ref. system and expressed in the latter
- send_position_setpoint with yaw=0

REFERENCE SYSTEMS
- fixed Vicon: flight room center, _v, (at cg level?)
- fixed Start: cg Drone at startup, _#, navigation frame, coplanar with V, z=0, same orientation as V
    (intended as parallel axis, not equal angles)
- body Start: cg Drone at each instant t_i, _i, {x towards bow, y towards left, z upwards}, only yaw changes (pitch and
    roll supposed null)
- Vicon measures expressed in V
- RPY
- measures supposed by the program as in a system (S_i) with:
    origin -> nav system   (or actually the frame is parallel?)
    frame -> rotated with actual yaw
- Drone thinks to be in S_# (yaw=0 always)
- Wand orientation irrelevant

- Vicon gets Drone position in V
- Drone position then converted to S_i
- position of the Drone sent to KF only after take-off

- Vicon gets P^v_vf (position after take-off, in V ref. sys, relative to V origin)
- through the rotation matrix we get P^si_vf (after take-off, in S_i, relative to V origin)
- this is sent to the Drone as a target to follow
- once at goal position, through Vicon we get the actual yaw of the Drone and recompute the rotation matrix
- repeat every 100Hz

- once Wand is off, Vicon sends [0 0 0]
- Drone remains in its current position without moving
- if [0 0 0] is received a certain number of times, the Drone lands